substitutions:
  name: waveshare-epaper-6625d8
  friendly_name: SmartFrame Test

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}
  on_boot:
      priority: 200.0
      then:
        - component.update: eink_display
        - wait_until:
            condition:
              lambda: 'return id(data_updated) == true;'
              # Wait a bit longer so all the items are received
        - delay: 5s
        - logger.log: "Initial sensor data received: Refreshing display..."
        - lambda: 'id(initial_data_received) = true;'
        - script.execute: update_screen

esp32:
  board: esp32dev
  framework:
    type: arduino

# Pins for Waveshare ePaper ESP Board
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "VJMi9X5Fk8nSx/45ycpJzCBrWyF4XxG2TyTheGcjgdY="
ota:
  password: "3a328410f03e6b4c2e45ba985dc11ad7"

# Wifi information
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ${name}
    password: ${name}

captive_portal:

###############################################################################
###############################################################################
###############################################################################

button:
  - platform: shutdown
    name: "SmartFrame - Shutdown"
  - platform: restart
    name: "SmartFrame - Restart"
  - platform: template
    name: "SmartFrame - Refresh Screen"
    entity_category: config
    on_press:
      - script.execute: update_screen
      
      
# Global variables for detecting if the display needs to be refreshed. (Thanks @paviro!)
globals:
  - id: data_updated
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: initial_data_received
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: recorded_display_refresh
    type: int
    restore_value: yes
    initial_value: '0'


# Script for updating screen - Refresh display and publish refresh count and time. (Thanks @paviro!)
script:
  - id: update_screen
    then:
      - lambda: 'id(data_updated) = false;'
      - component.update: eink_display
      - lambda: 'id(recorded_display_refresh) += 1;'
      - lambda: 'id(display_last_update).publish_state(id(homeassistant_time).now().timestamp);'
      

# Check whether the display needs to be refreshed every minute,
# based on whether new data is received or motion is detected. (Thanks @paviro!)
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: 0
        minutes: /1
        then:
          - if:
              condition:
                lambda: 'return id(data_updated) == true;'
              then:
                - if:
                    condition:
                      binary_sensor.is_on: hallway_motion_detected
                    then:
                      - logger.log: "Sensor data updated and activity in home detected: Refreshing display..."
                      - script.execute: update_screen
                    else:
                      - logger.log: "Sensor data updated but no activity in home - skipping display refresh."
              else:
                - logger.log: "No sensors updated - skipping display refresh."


###############################################################################
###############################################################################
###############################################################################

# Check if motion is detected in the living room.
binary_sensor:
  - platform: homeassistant
    entity_id: binary_sensor.hallway_motion_motion
    id: hallway_motion_detected

text_sensor:
  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: shorttime0
    id: hourly_forecast_shorttime0
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: condition0
    id: hourly_forecast_condition0
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: shorttime1
    id: hourly_forecast_shorttime1
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: condition1
    id: hourly_forecast_condition1
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: shorttime2
    id: hourly_forecast_shorttime2
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: condition2
    id: hourly_forecast_condition2
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: shorttime3
    id: hourly_forecast_shorttime3
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: condition3
    id: hourly_forecast_condition3
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: weather.forecast_home
    id: weather_current
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

sensor:
  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: temperature0
    id: hourly_forecast_temperature0
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: temperature1
    id: hourly_forecast_temperature1
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: temperature2
    id: hourly_forecast_temperature2
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.weather_forecast_hourly
    attribute: temperature3
    id: hourly_forecast_temperature3
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.front_garden_climate_temperature 
    id: weather_current_temp
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  - platform: homeassistant
    entity_id: sensor.front_garden_climate_humidity
    id: weather_current_humidity
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'
    
  - platform: homeassistant
    entity_id: sensor.front_garden_climate_pressure
    id: weather_current_pressure
    on_value:
      then:
        - lambda: 'id(data_updated) = true;'

  # Create sensors for monitoring SmartFrame remotely.
  - platform: template
    name: "SmartFrame - Display Last Update"
    device_class: timestamp
    entity_category: "diagnostic"
    id: display_last_update
    
  - platform: template
    name: "SmartFrame - Recorded Display Refresh"
    accuracy_decimals: 0
    unit_of_measurement: "Refreshes"
    state_class: "total_increasing"
    entity_category: "diagnostic"
    lambda: 'return id(recorded_display_refresh);'
  
  - platform: wifi_signal
    name: "SmartFrame - WiFi Signal Strength"
    id: wifisignal
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
    update_interval: 60s

###############################################################################
###############################################################################
###############################################################################

# Include custom fonts
font:
  - file: "gfonts://Roboto"
    id: roboto_20
    size: 20
  - file: "gfonts://Roboto"
    id: roboto_40
    size: 40
  - file: "https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/fonts/materialdesignicons-webfont.ttf"
    id: icons_50
    size: 50
    glyphs: &mdi-weather-glyphs
      - "\U000F0590" # mdi-weather-cloudy
      - "\U000F0F2F" # mdi-weather-cloudy-alert
      - "\U000F0E6E" # mdi-weather-cloudy-arrow-right
      - "\U000F0591" # mdi-weather-fog
      - "\U000F0592" # mdi-weather-hail
      - "\U000F0F30" # mdi-weather-hazy
      - "\U000F0898" # mdi-weather-hurricane
      - "\U000F0593" # mdi-weather-lightning
      - "\U000F067E" # mdi-weather-lightning-rainy
      - "\U000F0594" # mdi-weather-night
      - "\U000F0F31" # mdi-weather-night-partly-cloudy
      - "\U000F0595" # mdi-weather-partly-cloudy
      - "\U000F0F32" # mdi-weather-partly-lightning
      - "\U000F0F33" # mdi-weather-partly-rainy
      - "\U000F0F34" # mdi-weather-partly-snowy
      - "\U000F0F35" # mdi-weather-partly-snowy-rainy
      - "\U000F0596" # mdi-weather-pouring
      - "\U000F0597" # mdi-weather-rainy
      - "\U000F0598" # mdi-weather-snowy
      - "\U000F0F36" # mdi-weather-snowy-heavy
      - "\U000F067F" # mdi-weather-snowy-rainy
      - "\U000F0599" # mdi-weather-sunny
      - "\U000F0F37" # mdi-weather-sunny-alert
      - "\U000F14E4" # mdi-weather-sunny-off
      - "\U000F059A" # mdi-weather-sunset
      - "\U000F059B" # mdi-weather-sunset-down
      - "\U000F059C" # mdi-weather-sunset-up
      - "\U000F0F38" # mdi-weather-tornado
      - "\U000F059D" # mdi-weather-windy
      - "\U000F059E" # mdi-weather-windy-variant

# Now render everything on the ePaper screen (480x800)
display:
  - platform: waveshare_epaper
    id: eink_display
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin: GPIO25
    reset_pin: GPIO26
    reset_duration: 2ms
    model: 7.50inV2
    update_interval: never
    rotation: 90°
    lambda: |-
      std::map<std::string, std::string> weather_icon_map
      {
        {"cloudy", "\U000F0590"},
        {"cloudy-alert", "\U000F0F2F"},
        {"cloudy-arrow-right", "\U000F0E6E"},
        {"fog", "\U000F0591"},
        {"hail", "\U000F0592"},
        {"hazy", "\U000F0F30"},
        {"hurricane", "\U000F0898"},
        {"lightning", "\U000F0593"},
        {"lightning-rainy", "\U000F067E"},
        {"night", "\U000F0594"},
        {"night-partly-cloudy", "\U000F0F31"},
        {"partlycloudy", "\U000F0595"},
        {"partly-lightning", "\U000F0F32"},
        {"partly-rainy", "\U000F0F33"},
        {"partly-snowy", "\U000F0F34"},
        {"partly-snowy-rainy", "\U000F0F35"},
        {"pouring", "\U000F0596"},
        {"rainy", "\U000F0597"},
        {"snowy", "\U000F0598"},
        {"snowy-heavy", "\U000F0F36"},
        {"snowy-rainy", "\U000F067F"},
        {"sunny", "\U000F0599"},
        {"sunny-alert", "\U000F0F37"},
        {"sunny-off", "\U000F14E4"},
        {"sunset", "\U000F059A"},
        {"sunset-down", "\U000F059B"},
        {"sunset-up", "\U000F059C"},
        {"tornado", "\U000F0F38"},
        {"windy", "\U000F059D"},
        {"windy-variant", "\U000F059E"},
      };
      std::map<std::string, std::string> weather_name_map
      {
        {"cloudy", "Cloudy"},
        {"cloudy-alert", "Cloudy"},
        {"cloudy-arrow-right", "Cloudy"},
        {"fog", "Fog"},
        {"hail", "Hail"},
        {"hazy", "Hazy"},
        {"hurricane", "Hurricane"},
        {"lightning", "Lightning"},
        {"lightning-rainy", "Rain & Lightning"},
        {"night", "Clear"},
        {"night-partly-cloudy", "Partly\nCloudy"},
        {"partlycloudy", "Partly\nCloudy"},
        {"partly-lightning", "Lightning"},
        {"partly-rainy", "Rainy"},
        {"partly-snowy", "Snowy"},
        {"partly-snowy-rainy", "Sleet"},
        {"pouring", "Raining"},
        {"rainy", "Rain"},
        {"snowy", "Snow"},
        {"snowy-heavy", "Heavy Snow"},
        {"snowy-rainy", "Sleet"},
        {"sunny", "Sunny"},
        {"sunny-alert", "Sunny"},
        {"sunny-off", "Sunny"},
        {"sunset", "Sunset"},
        {"sunset-down", "Sunset"},
        {"sunset-up", "Sunset"},
        {"tornado", "Tornado"},
        {"windy", "Windy"},
        {"windy-variant", "Windy"},
      };

      // Show loading screen before data is received.
      if (id(initial_data_received) == false) {
        it.printf(240, 400, id(roboto_40), TextAlign::TOP_CENTER, "WAITING FOR DATA...");
      } else {

        // Weather Section
        it.printf(20, 20, id(roboto_40), TextAlign::TOP_LEFT, "WEATHER");

        it.printf(60, 80, id(roboto_20), TextAlign::TOP_CENTER, "NOW");
        it.printf(60, 110, id(roboto_20), TextAlign::TOP_CENTER, "%2.0f°C", id(weather_current_temp).state);
        it.printf(60, 170, id(icons_50), TextAlign::TOP_CENTER, "%s", weather_icon_map[id(weather_current).state.c_str()].c_str());
        it.printf(60, 200, id(roboto_20), TextAlign::TOP_CENTER, "%s", weather_name_map[id(weather_current).state.c_str()].c_str());

        it.printf(150, 80, id(roboto_20), TextAlign::TOP_CENTER, "%s", id(hourly_forecast_shorttime0).state.c_str());
        it.printf(150, 110, id(roboto_20), TextAlign::TOP_CENTER, "%2.0f°C", id(hourly_forecast_temperature0).state);
        it.printf(150, 170, id(icons_50), TextAlign::TOP_CENTER, "%s", weather_icon_map[id(hourly_forecast_condition0).state.c_str()].c_str());
        it.printf(150, 200, id(roboto_20), TextAlign::TOP_CENTER, "%s", weather_name_map[id(hourly_forecast_condition0).state.c_str()].c_str());

        it.printf(240, 80, id(roboto_20), TextAlign::TOP_CENTER, "%s", id(hourly_forecast_shorttime1).state.c_str());
        it.printf(240, 110, id(roboto_20), TextAlign::TOP_CENTER, "%2.0f°C", id(hourly_forecast_temperature1).state);
        it.printf(240, 170, id(icons_50), TextAlign::TOP_CENTER, "%s", weather_icon_map[id(hourly_forecast_condition1).state.c_str()].c_str());
        it.printf(240, 200, id(roboto_20), TextAlign::TOP_CENTER, "%s", weather_name_map[id(hourly_forecast_condition1).state.c_str()].c_str());

        it.printf(330, 80, id(roboto_20), TextAlign::TOP_CENTER, "%s", id(hourly_forecast_shorttime2).state.c_str());
        it.printf(330, 110, id(roboto_20), TextAlign::TOP_CENTER, "%2.0f°C", id(hourly_forecast_temperature2).state);
        it.printf(330, 170, id(icons_50), TextAlign::TOP_CENTER, "%s", weather_icon_map[id(hourly_forecast_condition2).state.c_str()].c_str());
        it.printf(330, 200, id(roboto_20), TextAlign::TOP_CENTER, "%s", weather_name_map[id(hourly_forecast_condition2).state.c_str()].c_str());

        it.printf(420, 80, id(roboto_20), TextAlign::TOP_CENTER, "%s", id(hourly_forecast_shorttime3).state.c_str());
        it.printf(420, 110, id(roboto_20), TextAlign::TOP_CENTER, "%2.0f°C", id(hourly_forecast_temperature3).state);
        it.printf(420, 170, id(icons_50), TextAlign::TOP_CENTER, "%s", weather_icon_map[id(hourly_forecast_condition3).state.c_str()].c_str());
        it.printf(420, 100, id(roboto_20), TextAlign::TOP_CENTER, "%s", weather_name_map[id(hourly_forecast_condition3).state.c_str()].c_str());

        // Refresh Timestamp
        // Code by EnsconcE from https://community.home-assistant.io/t/esphome-show-time/348903
        char str[17];
        time_t currTime = id(homeassistant_time).now().timestamp;
        strftime(str, sizeof(str), "%H:%M", localtime(&currTime));
        it.printf(470, 790, id(roboto_20), TextAlign::BOTTOM_RIGHT, "REFRESHED AT %s", str);
      }
